<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>AI-Powered CSV to Chart + Explanation</title>
		
		<!-- Primary Meta Tags -->
		<meta name="description" content="Upload your CSV files and automatically generate interactive charts and professional explanations powered by AI. Easy data visualization and analysis for business and personal use." />
		<meta name="keywords" content="CSV chart generator, AI data visualization, Chart.js, AI explanation, CSV to chart, business intelligence, data analysis tool" />
		<meta name="author" content="Yap Wei Jun" />
		
		<!-- Open Graph / Facebook -->
		<meta property="og:type" content="website" />
		<meta property="og:title" content="AI-Powered CSV to Chart & Explanation Tool" />
		<meta property="og:description" content="Upload your CSV files and automatically generate interactive charts and professional explanations powered by AI." />
		<meta property="og:url" content="https://yapweijun1996.github.io/CSV-AI-Chart-and-Explanation-v2/" />
		<meta property="og:image" content="https://yapweijun1996.github.io/CSV-AI-Chart-and-Explanation-v2/og_img.jpg" />
		
		<!-- Twitter -->
		<meta name="twitter:card" content="summary_large_image" />
		<meta name="twitter:title" content="AI-Powered CSV to Chart & Explanation Tool" />
		<meta name="twitter:description" content="Upload your CSV files and automatically generate interactive charts and professional explanations powered by AI." />
		<meta name="twitter:image" content="https://yapweijun1996.github.io/CSV-AI-Chart-and-Explanation-v2/og_img.jpg" />
		
		<!-- SEO-friendly canonical URL -->
		<link rel="canonical" href="https://yapweijun1996.github.io/CSV-AI-Chart-and-Explanation-v2/" />
		
		
		<style>
			/* Basic styling for body with font and max width */
			body {
				font-family: Arial, sans-serif;
				margin: 20px auto;
				max-width: 900px;
			}
			h1 {
				margin-bottom: 10px;
			}
			
			ul li {
				margin-top: 10px;
			}
			/* Margin between input elements */
			#csvInput, #chartTypeSelect {
				margin-bottom: 10px;
			}
			
			/* Container for chart with border and padding */
			#chartContainer {
				border: 1px solid #ccc;
				background: white;
				padding: 10px;
				position: relative; /* allows absolutely positioned loader inside */
			}
			
			/* Explanation text container styling */
			#explanation {
				margin-top: 20px;
				background: #eef;
				padding: 15px;
				border-radius: 4px;
				min-height: 80px;
				position: relative; /* for loader absolute positioning */
			}
			
			/* Bold text inside explanation */
			#explanation strong {
				font-weight: 700;
			}
			
			#explanationText {
				font-family: "FangSong", Arial, sans-serif;
			}
			
			/* Container for extracted table data */
			#dataTableContainer {
				margin-top: 20px;
				position: relative; /* for loader absolute positioning */
			}
			
			/* Table styling for extracted data */
			#dataTable table {
				font-family: Arial, sans-serif;
				border-collapse: collapse;
				width: 100%;
				margin-top: 10px;
			}
			#dataTable th, #dataTable td {
				border: 1px solid #ccc;
				padding: 8px;
				text-align: left;
			}
			#dataTable th {
				background-color: #f2f2f2;
			}
			
			/* Loading spinner style */
			.loading-spinner {
				display: none; /* hidden by default */
				width: 24px;
				height: 24px;
				border: 3px solid #ccc;
				border-top-color: #007acc; /* blue color for spinner */
				border-radius: 50%;
				animation: spin 1s linear infinite;
				vertical-align: middle;
				margin-left: 8px;
				position: absolute; /* positioned relative to container */
				top: 10px;
			}
			
			/* Animation keyframes for spinner rotation */
			@keyframes spin {
				to { transform: rotate(360deg); }
			}
			
			/* Positioning loaders in respective containers */
			#loadingChart {
				left: 10px;
				top: 15px;
			}
			#loadingExplanation {
				right: 10px;
			}
			#loadingDataTable {
				left: 10px;
				top: 35px; /* Lower so does not overlap header */
			}
			
			/* Header texts with inline loaders */
			#explanation strong, #dataTableContainer > strong {
				display: inline-flex;
				align-items: center;
			}

			/* Save button styling - fixed top right */
			#saveHtmlBtn {
				position: fixed;
				top: 10px;
				right: 10px;
				z-index: 9999;
				padding: 8px 12px;
				font-size: 14px;
				cursor: pointer;
			}
		</style>
	</head>
	<body>
		
		<!-- Save as HTML button -->
		<button id="saveHtmlBtn" title="Save current chart, table and explanation as standalone HTML">Save as HTML</button>

		<div style="margin-bottom: 15px;">
			<h1>Upload CSV & AI-Driven Chart + Explanation</h1>
			
			<!-- File input for CSV upload -->
			<input type="file" id="csvInput" accept=".csv" />
			<br/>
			
			<!-- Dropdown to select chart type -->
			<label for="chartTypeSelect">Chart Type:</label>
			<select id="chartTypeSelect">
				<option value="bar" selected>Bar Chart</option>
				<option value="line">Line Chart</option>
				<option value="area">Area Chart</option>
				<option value="bubble">Bubble Chart</option>
				<option value="doughnut">Doughnut Chart</option>
				<option value="pie">Pie Chart</option>
				<option value="polarArea">Polar Area Chart</option>
				<option value="radar">Radar Chart</option>
				<option value="scatter">Scatter Chart</option>
			</select>
			
			<br/>
			<label for="languageSelect">Summary Language:</label>
			<select id="languageSelect">
				<option value="English" selected>English</option>
				<option value="Mandarin">Mandarin (中文)</option>
				<option value="Malay">Malay (Bahasa Melayu)</option>
				<option value="Japanese">Japanese (日本語)</option>
				<option value="Korean">Korean (한국어)</option>
				<option value="Spanish">Spanish (Español)</option>
				<option value="French">French (Français)</option>
				<option value="German">German (Deutsch)</option>
				<option value="Hindi">Hindi (हिन्दी)</option>
				<option value="Arabic">Arabic (العربية)</option>
				<option value="Portuguese">Portuguese (Português)</option>
				<option value="Russian">Russian (Русский)</option>
			</select>
		</div>
		
		<!-- Container to render Chart.js chart -->
		<div id="chartContainer">
			<canvas id="chartCanvas" width="800" height="400"></canvas>
			<!-- Loader spinner shown while chart is being generated -->
			<div id="loadingChart" class="loading-spinner" title="Generating chart..."></div>
		</div>
		
		<!-- Container to display explanation generated by AI -->
		<div id="explanation">
			<strong>Explanation:
				<!-- Loader spinner shown while explanation is generating -->
				<div id="loadingExplanation" class="loading-spinner" title="Generating explanation..."></div>
			</strong>
			<div id="explanationText">Waiting for CSV upload...</div>
		</div>
		
		<!-- Container to show extracted clean table data -->
		<div id="dataTableContainer">
			<strong>Extracted Table Data:
				<!-- Loader spinner shown while extracting table data -->
				<div id="loadingDataTable" class="loading-spinner" title="Extracting data..."></div>
			</strong>
			<div id="dataTable">No data loaded yet.</div>
		</div>
		
		<!-- Load Chart.js library from CDN -->
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<!-- Load marked.js library to convert markdown text to HTML -->
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		
		<script>
			// ===== Gemini AI integration section =====
			
			// Configuration for AI text generation, like temperature, max tokens, etc.
			const generationConfig = {
				temperature: 1,
				topP: 0.95,
				topK: 40,
				maxOutputTokens: 65536,
				responseMimeType: "text/plain",
				thinkingConfig: {
					thinkingBudget: -1 // no limit on AI "thinking" time
				}
			};
			
			// Key used to decrypt the encrypted API keys below
			var KEY = "20250710";
			
			// Simple XOR decryption function for encrypted API keys
			function decrypt(ciphertext) {
				let decodedMessage = '';
				for (let i = 0; i < ciphertext.length; i += 3) {
					let numStr = ciphertext.slice(i, i + 3);
					let encryptedChar = parseInt(numStr);
					let keyChar = KEY.charCodeAt((i / 3) % KEY.length);
					let decryptedChar = encryptedChar ^ keyChar; // XOR operation
					decodedMessage += String.fromCharCode(decryptedChar);
				}
				return decodedMessage;
			}
			
			// Encrypted API keys for Gemini AI; you can replace or add your own keys here
			var apiKeys = [
				"115121072084099078114106098029005120126090119105075090121123125069122116094086126071121120084125067121099109004000086", // can share
				"115121072084099078115106107073097127003091070122066093074007070026117113095097102119085065092117113084101066074065070" // can share
			];
			
			// Index to track which API key is currently being used
			let currentKeyIndex = 0;
			
			// Function to send request to Gemini AI API with retry across multiple keys
			async function sendApiRequest(url, requestBody) {
				let tries = 0;
				const maxTries = apiKeys.length;
				
				while (tries < maxTries) {
					var apiKey = apiKeys[currentKeyIndex];
					apiKey = decrypt(apiKey); // Decrypt the API key before use
					
					const fullUrl = url + "?key=" + apiKey;
					
					try {
						const response = await fetch(fullUrl, {
							method: "POST",
							headers: { "Content-Type": "application/json" },
							body: JSON.stringify(requestBody),
						});
						
						if (response.ok) {
							const data = await response.json();
							return data;
						} else {
							// Switch to next API key and retry
							currentKeyIndex = (currentKeyIndex + 1) % apiKeys.length;
							tries++;
						}
					} catch (err) {
						// On error, switch to next API key and retry
						currentKeyIndex = (currentKeyIndex + 1) % apiKeys.length;
						tries++;
					}
				}
				// Throw error if all keys fail
				throw new Error("All API keys failed.");
			}
			
			// Helper function to start a Gemini chat session with a selected AI model
			async function startChatSession(selectedModel) {
				return {
					sendMessage: async function(messageData) {
						// Normalize user message format
						let userMessage = typeof messageData === "string"
						? { role: "user", parts: [{ text: messageData }] }
						: messageData;
						
						// Request body includes message and generation config
						const requestBody = { contents: [userMessage], generationConfig };
						const url = "https://generativelanguage.googleapis.com/v1beta/models/" + selectedModel + ":generateContent";
						
						const result = await sendApiRequest(url, requestBody);
						
						if (result.candidates && result.candidates.length > 0) {
							return result.candidates[0].content.parts;
						} else {
							throw new Error("No response from API");
						}
					}
				};
			}
			// ===== End Gemini AI integration =====
			
			// Global variable to hold Chart.js instance so we can destroy old chart before drawing new
			let currentChart = null;
			
			// DOM references
			const csvInput = document.getElementById('csvInput');
			const chartTypeSelect = document.getElementById('chartTypeSelect');
			const languageSelect = document.getElementById('languageSelect');
			const loadingChart = document.getElementById('loadingChart');
			const loadingExplanation = document.getElementById('loadingExplanation');
			const loadingDataTable = document.getElementById('loadingDataTable');
			const explanationEl = document.getElementById('explanationText');
			const dataTableDiv = document.getElementById('dataTable');
			const saveHtmlBtn = document.getElementById('saveHtmlBtn');
			
			// Function to extract the first valid JSON object or array from a text string (for parsing AI responses)
			function extractFirstJSONObject(text) {
				text = text.trim();
				
				// Remove markdown JSON code fences if present
				if (text.startsWith("```json")) {
					text = text.slice(7).trim();
				}
				if (text.endsWith("```")) {
					text = text.slice(0, -3).trim();
				}
				
				// Find where the JSON object or array starts
				let start = text.indexOf('{');
				let startArr = text.indexOf('[');
				if (startArr >= 0 && (startArr < start || start < 0)) {
					start = startArr;
				}
				if (start < 0) throw new Error("No JSON object found");
				
				// Parse character by character to find balanced braces/brackets to detect JSON boundaries
				let braceCount = 0;
				let inString = false;
				for (let i = start; i < text.length; i++) {
					const ch = text[i];
					if (ch === '"' && text[i-1] !== '\\') {
						inString = !inString;
					}
					if (!inString) {
						if (ch === '{' || ch === '[') braceCount++;
						else if (ch === '}' || ch === ']') braceCount--;
						if (braceCount === 0) {
							return text.slice(start, i + 1);
						}
					}
				}
				throw new Error("No complete JSON object found");
			}
			
			// Function to render Chart.js chart given config and chartType
			function renderChart(config, chartType) {
				// Special case: 'area' chart is just a filled line chart in Chart.js
				if (chartType === 'area' && config.type === 'line' && Array.isArray(config.data.datasets)) {
					config.data.datasets.forEach(ds => {
						ds.fill = true; // fill under line
						if (!ds.backgroundColor) ds.backgroundColor = 'rgba(75, 192, 192, 0.2)';
					});
				}
				const ctx = document.getElementById('chartCanvas').getContext('2d');
				if (currentChart) currentChart.destroy(); // destroy previous chart to avoid overlap
				currentChart = new Chart(ctx, config);
			}
			
			// Convert markdown explanation text to HTML and display it
			function renderExplanation(markdownText) {
				explanationEl.innerHTML = marked.parse(markdownText);
			}
			
			
			function addSubtotalRow(data) {
				if (!Array.isArray(data) || data.length === 0) return data;
				
				const columns = Object.keys(data[0]);
				
				// Determine numeric columns (all rows must have number or numeric string)
				const numericCols = columns.filter(col =>
					data.every(row => {
						const val = row[col];
						return val !== null && val !== undefined && !isNaN(parseFloat(val)) && isFinite(val);
					})
				);
				
				if (numericCols.length === 0) return data; // no numeric columns, no subtotal needed
				
				// Check if last row already contains a total/subtotal label in any non-numeric column
				const lastRow = data[data.length - 1];
				const hasTotalLabel = columns.some(col => {
					if (!numericCols.includes(col)) {
						const cell = lastRow[col];
						if (typeof cell === "string") {
							const lowered = cell.trim().toLowerCase();
							return lowered === "total" || lowered === "subtotal";
						}
					}
					return false;
				});
				
				if (hasTotalLabel) {
					// Last row is already total, return as is
					return data;
				}
				
				// Calculate sums for numeric columns
				const subtotalRow = {};
				columns.forEach(col => {
					if (numericCols.includes(col)) {
						subtotalRow[col] = data.reduce((sum, row) => sum + Number(row[col]), 0);
					} else {
						subtotalRow[col] = '';
					}
				});
				
				// Put label "Total" in first non-numeric column or first column
				let labelSet = false;
				for (const col of columns) {
					if (!numericCols.includes(col)) {
						subtotalRow[col] = 'Total';
						labelSet = true;
						break;
					}
				}
				if (!labelSet) {
					subtotalRow[columns[0]] = 'Total';
				}
				
				return [...data, subtotalRow];
			}
			
			
			
			// Render extracted JSON table data as an HTML table
			function renderDataTable(data) {
				// Cache data globally so chart can be regenerated without re-uploading file
				window.cleanDataCache = data;
				
				if (!data || data.length === 0) {
					dataTableDiv.innerHTML = "<p>No data to display.</p>";
					return;
				}
				
				const columns = Object.keys(data[0]);
				let html = `<table><thead><tr>`;
				columns.forEach(col => html += `<th>${col}</th>`);
				html += `</tr></thead><tbody>`;
				
				data.forEach(row => {
					html += '<tr>';
					columns.forEach(col => {
						// Use empty string if value is undefined or null
						html += `<td>${row[col] ?? ''}</td>`;
					});
					html += '</tr>';
				});
				
				html += `</tbody></table>`;
				dataTableDiv.innerHTML = html;
			}
			
			// Use AI to extract a clean JSON array from raw CSV text
			async function aiAgentExtractTable(rawCsvText, maxRetry = 3) {
				// Prompt to ask AI to extract structured JSON from CSV text
				const prompt = `
					You are a helpful assistant specialized in data extraction.
					
					Given the following CSV file content as plain text:
					
					\`\`\`
					${rawCsvText}
					\`\`\`
					
					Please extract and generate a clean JSON array of objects representing the main tabular data only.
					
					- Ignore any titles, headers unrelated to the data, summaries, or empty rows.
					- Infer consistent and meaningful keys from the column headers.
					- For numeric values formatted with commas (e.g., "999,999,999.99"), remove the commas so they become plain numbers (e.g., "999999999.99").
					- Ensure the JSON is well-structured, with uniform keys for all objects.
					- Output ONLY the JSON array without any additional explanation or text.
					`;
				
				let attempt = 0;
				while (attempt < maxRetry) {
					try {
						loadingDataTable.style.display = 'inline-block'; // show loading spinner
						const session = await startChatSession("gemini-2.5-pro");
						const responseParts = await session.sendMessage(prompt);
						loadingDataTable.style.display = 'none'; // hide spinner
						
						// Combine text parts returned from AI
						const responseText = responseParts.filter(p => p.text).map(p => p.text).join('').trim();
						console.log("AI raw response:", responseText);
						
						// Extract JSON from AI text response
						const jsonText = extractFirstJSONObject(responseText);
						const jsonData = JSON.parse(jsonText);
						
						return jsonData; // return parsed JSON array
					} catch (err) {
						console.log("Retry: aiAgentExtractTable");
						console.log(err);
						loadingDataTable.style.display = 'none';
						attempt++;
						if (attempt >= maxRetry) throw new Error("Failed to extract table: " + err.message);
						// Wait half a second before retrying
						await new Promise(r => setTimeout(r, 500));
					}
				}
			}
			
			// Use AI to generate Chart.js config JSON for the given clean data and chart type
			async function aiAgentGenerateChartConfig(cleanData, chartType, maxRetry = 3) {
				// Some AI models do not recognize 'area' as a chart type, so treat it as 'line'
				let promptChartType = chartType === 'area' ? 'line' : chartType;
				
				const prompt = `
					You are a professional assistant generating Chart.js configuration.
					
					Input: A JSON array of data objects representing tabular data:
					
					${JSON.stringify(cleanData)}
					
					Task: Generate a **valid JSON object** representing a Chart.js configuration for a "${promptChartType}" chart.
					
					Requirements:
					
					- Include these keys: "type", "data", and "options".
					- In "data", create "labels" from suitable data columns, and "datasets" with numeric data.
					- In "options", include axis titles, responsive settings, legend and tooltip configuration objects.
					- Use consistent and visually distinct colors for dataset backgrounds and borders.
					- Do NOT include any JavaScript functions, callbacks, or expressions.
					- For any callbacks or dynamic features, use empty objects or omit them.
					- Format numeric values as plain numbers, no string formatting.
					- The output must be parsable by JSON.parse().
					- Output ONLY the JSON object, no additional text or explanation.
					
					If input data is invalid or insufficient to generate a chart, output an empty JSON object: {}.
					
					`;
				
				let attempt = 0;
				while (attempt < maxRetry) {
					loadingChart.style.display = 'inline-block'; // show loading spinner
					const session = await startChatSession("gemini-2.5-pro");
					const responseParts = await session.sendMessage(prompt);
					console.log("aiAgentGenerateChartConfig, responseParts:");
					console.log(responseParts);
					
					try {
						loadingChart.style.display = 'none'; // hide spinner
						
						const responseText = responseParts.filter(p => p.text).map(p => p.text).join('').trim();
						const jsonText = extractFirstJSONObject(responseText);
						const chartConfig = JSON.parse(jsonText);
						
						return chartConfig;
					} catch (err) {
						console.log("Retry: aiAgentGenerateChartConfig");
						console.log(err);
						loadingChart.style.display = 'none';
						attempt++;
						if (attempt >= maxRetry) throw new Error("Failed to generate chart config: " + err.message);
						await new Promise(r => setTimeout(r, 500));
					}
				}
			}
			
			// Use AI to generate a professional explanation for the generated chart config
			async function aiAgentGenerateExplanation(chartConfig, language = 'English', maxRetry = 3) {
				const prompt = `
					You are a senior data analyst preparing a professional report for senior management.
					
					Please provide the report in ${language}.
					
					Given the following Chart.js configuration JSON data representing key performance metrics from an ERP system process:
					
					${JSON.stringify(chartConfig, null, 2)}
					
					Please provide a clear, concise, and formal report structured as follows:
					
					1. Executive Summary — Describe the chart’s purpose and summarize the overall findings.
					
					2. Key Observations — Identify important insights like trends, comparisons, anomalies, ratios, etc.
					
					3. Business Implications — Explain impact on business or operations.
					
					4. Actionable Recommendations — Practical suggestions based on data.
					
					5. Potential Risks or Considerations — Any risks or data issues to monitor.
					
					6. Data Summary — Summarize key data points.
					
					Use professional language appropriate for senior management. Present the report in bullet points or concise paragraphs. Output only the report text.
					`;
				
				let attempt = 0;
				while (attempt < maxRetry) {
					try {
						loadingExplanation.style.display = 'inline-block'; // show spinner
						const session = await startChatSession("gemini-2.5-pro");
						const responseParts = await session.sendMessage(prompt);
						loadingExplanation.style.display = 'none'; // hide spinner
						
						const explanationText = responseParts.filter(p => p.text).map(p => p.text).join('\n').trim();
						return explanationText;
					} catch (err) {
						console.log("Retry: aiAgentGenerateExplanation");
						console.log(err);
						loadingExplanation.style.display = 'none';
						attempt++;
						if (attempt >= maxRetry) throw new Error("Failed to generate explanation: " + err.message);
						await new Promise(r => setTimeout(r, 500));
					}
				}
			}
			
			
			// Event listener for CSV file upload
			csvInput.addEventListener('change', (e) => {
				const file = e.target.files[0];
				if (!file) return;
				
				explanationEl.textContent = "Reading CSV file...";
				dataTableDiv.innerHTML = "";
				if (currentChart) currentChart.destroy();
				
				const reader = new FileReader();
				reader.onload = async function(event) {
					const rawCsvText = event.target.result;
					
					try {
						explanationEl.textContent = "AI extracting clean table data...";
						const cleanData = await aiAgentExtractTable(rawCsvText);
						const dataWithSubtotal = addSubtotalRow(cleanData);
						renderDataTable(dataWithSubtotal);
						
						const chartType = chartTypeSelect.value;
						
						explanationEl.textContent = "AI generating chart configuration...";
						const chartConfig = await aiAgentGenerateChartConfig(dataWithSubtotal, chartType);
						window.currentChartConfig = chartConfig;
						
						renderChart(chartConfig, chartType);
						
						explanationEl.textContent = "AI generating chart explanation...";
						const language = languageSelect.value || 'English';
						const explanation = await aiAgentGenerateExplanation(chartConfig, language);
						renderExplanation(explanation);
					} catch (err) {
						// Display error and clear chart/table on failure
						explanationEl.textContent = "Error: " + err.message;
						dataTableDiv.innerHTML = "";
						if (currentChart) currentChart.destroy();
					}
				};
				reader.readAsText(file);
			});
			
			
			// Event listener for chart type dropdown change
			chartTypeSelect.addEventListener('change', async () => {
				// Only regenerate if we have cached clean data from previous upload
				if (!window.cleanDataCache || window.cleanDataCache.length === 0) return;
				
				explanationEl.textContent = "Regenerating chart and explanation with new chart type...";
				
				try {
					const chartType = chartTypeSelect.value;
					const dataWithSubtotal = addSubtotalRow(window.cleanDataCache);
					const chartConfig = await aiAgentGenerateChartConfig(dataWithSubtotal, chartType);
					window.currentChartConfig = chartConfig;
					renderChart(chartConfig, chartType);
					
					const language = languageSelect.value || 'English';
					const explanation = await aiAgentGenerateExplanation(chartConfig, language);
					renderExplanation(explanation);
				} catch (err) {
					explanationEl.textContent = "Error: " + err.message;
					if (currentChart) currentChart.destroy();
				}
			});
			
			// Update font family based on language selection
			function updateFontFamily() {
				if (languageSelect.value === 'Mandarin') {
					explanationEl.style.fontFamily = '"FangSong", serif';
				} else {
					explanationEl.style.fontFamily = 'Arial, sans-serif';
				}
			}
			updateFontFamily();
			languageSelect.addEventListener('change', async () => {
				updateFontFamily();
				
				// If no chart yet, no need to regenerate
				if (!window.currentChartConfig) return;
				
				try {
					explanationEl.textContent = "Regenerating explanation in new language...";
					loadingExplanation.style.display = 'inline-block';
					
					const language = languageSelect.value || 'English';
					const explanation = await aiAgentGenerateExplanation(window.currentChartConfig, language);
					
					loadingExplanation.style.display = 'none';
					renderExplanation(explanation);
				} catch (err) {
					loadingExplanation.style.display = 'none';
					explanationEl.textContent = "Error regenerating explanation: " + err.message;
				}
			});
			
			
			saveHtmlBtn.addEventListener('click', () => {
  try {
    // Clone the body element to manipulate for saving
    const clonedBody = document.body.cloneNode(true);

    // Remove the top control panel div by selector (margin-bottom:15px)
    const controlsDiv = clonedBody.querySelector('div[style*="margin-bottom: 15px"]');
    if (controlsDiv) {
      controlsDiv.remove();
    }

    // Remove the Save button itself in cloned body
    const saveBtnClone = clonedBody.querySelector('#saveHtmlBtn');
    if (saveBtnClone) {
      saveBtnClone.remove();
    }

    // Serialize the current chart config from live chart instance
    let chartConfigString = '{}';
    if (window.currentChartConfig) {
      chartConfigString = JSON.stringify(window.currentChartConfig);
    }

    // Build the saved HTML content with embedded chart config and code to re-initialize Chart.js
    const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Saved Chart & Report</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px auto;
      max-width: 900px;
      background: white;
      color: #000;
    }
    #explanation {
      margin-top: 20px;
      background: #eef;
      padding: 15px;
      border-radius: 4px;
      min-height: 80px;
      position: relative;
    }
    #explanation strong {
      font-weight: 700;
    }
    #explanationText {
      font-family: "FangSong", Arial, sans-serif;
    }
    #dataTable table {
      font-family: Arial, sans-serif;
      border-collapse: collapse;
      width: 100%;
      margin-top: 10px;
    }
    #dataTable th, #dataTable td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: left;
    }
    #dataTable th {
      background-color: #f2f2f2;
    }
    #chartContainer {
      border: 1px solid #ccc;
      background: white;
      padding: 10px;
      position: relative;
    }
  </style>
</head>
<body>
  ${clonedBody.innerHTML}

  <!-- Load Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></`+`script>

  <script>
    // Remove any existing Chart instance if any
    if(window.currentChart) {
      window.currentChart.destroy();
    }

    // Parse saved chart config
    const config = ${chartConfigString};

    // Adjust area chart fill if necessary (same logic as original)
    if(config.type === 'line' && config.data && Array.isArray(config.data.datasets)) {
      config.data.datasets.forEach(ds => {
        if(ds.fill === undefined) {
          ds.fill = false;
        }
      });
    }

    // Render chart on the existing canvas
    const ctx = document.getElementById('chartCanvas').getContext('2d');
    window.currentChart = new Chart(ctx, config);
  </`+`script>
</body>
</html>`;

    // Create a blob and trigger download
    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);

    // Create a temporary link to download
    const a = document.createElement('a');
    a.href = url;
    a.download = 'saved-chart-report.html';
    document.body.appendChild(a);
    a.click();

    // Cleanup
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 100);

  } catch (err) {
    alert("Failed to save HTML: " + err.message);
  }
});

		</script>
		
	</body>
</html>
